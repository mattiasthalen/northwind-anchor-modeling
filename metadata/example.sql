-- DATABASE INITIALIZATION -----------------------------------------------------
--
-- The following code performs the initial setup of the PostgreSQL database with
-- required objects for the anchor database.
--
--------------------------------------------------------------------------------
-- create schema
CREATE SCHEMA IF NOT EXISTS public;
-- set schema search path
SET search_path = public;
-- EQUIVALENTS METADATA -----------------------------------------------------------------------------------------------
--
-- Sets up a table containing the list of available equivalents. Since at least one equivalent
-- must be available the table is set up with a default equivalent with identity 0.
--
-- Equivalent table ---------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public._EQ (
    EQ smallint not null,
    constraint pk_EQ primary key (
        EQ
    )
)
;
-- If the default value already exists do nothing.
INSERT INTO public._EQ (
    EQ
) VALUES (
    0 -- the default equivalent
) ON CONFLICT DO NOTHING
;
-- KNOTS --------------------------------------------------------------------------------------------------------------
--
-- Knots are used to store finite sets of values, normally used to describe states
-- of entities (through knotted attributes) or relationships (through knotted ties).
-- Knots have their own surrogate identities and are therefore immutable.
-- Values can be added to the set over time though.
-- Knots should have values that are mutually exclusive and exhaustive.
-- Knots are unfolded when using equivalence.
--
-- ANCHORS AND ATTRIBUTES ---------------------------------------------------------------------------------------------
--
-- Anchors are used to store the identities of entities.
-- Anchors are immutable.
-- Attributes are used to store values for properties of entities.
-- Attributes are mutable, their values may change over one or more types of time.
-- Attributes have four flavors: static, historized, knotted static, and knotted historized.
-- Anchors may have zero or more adjoined attributes.
--
-- Anchor table -------------------------------------------------------------------------------------------------------
-- OH_Orders table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OH_Orders (
    OH_ID integer generated by default as identity not null,
    Metadata_OH integer not null, 
    constraint pkOH_Orders primary key (
        OH_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- OD_OrderDetails table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OD_OrderDetails (
    OD_ID integer generated by default as identity not null,
    Metadata_OD integer not null, 
    constraint pkOD_OrderDetails primary key (
        OD_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- CU_Customers table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CU_Customers (
    CU_ID integer generated by default as identity not null,
    Metadata_CU integer not null, 
    constraint pkCU_Customers primary key (
        CU_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- EM_Employees table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.EM_Employees (
    EM_ID integer generated by default as identity not null,
    Metadata_EM integer not null, 
    constraint pkEM_Employees primary key (
        EM_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- SH_Shippers table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SH_Shippers (
    SH_ID integer generated by default as identity not null,
    Metadata_SH integer not null, 
    constraint pkSH_Shippers primary key (
        SH_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- PR_Products table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.PR_Products (
    PR_ID integer generated by default as identity not null,
    Metadata_PR integer not null, 
    constraint pkPR_Products primary key (
        PR_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- SU_Suppliers table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.SU_Suppliers (
    SU_ID integer generated by default as identity not null,
    Metadata_SU integer not null, 
    constraint pkSU_Suppliers primary key (
        SU_ID 
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- CA_Categories table (with 0 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.CA_Categories (
    CA_ID integer generated by default as identity not null,
    Metadata_CA integer not null, 
    constraint pkCA_Categories primary key (
        CA_ID 
    )
);
-- TIES ---------------------------------------------------------------------------------------------------------------
--
-- Ties are used to represent relationships between entities.
-- They come in four flavors: static, historized, knotted static, and knotted historized.
-- Ties have cardinality, constraining how members may participate in the relationship.
-- Every entity that is a member in a tie has a specified role in the relationship.
-- Ties must have at least two anchor roles and zero or more knot roles.
--
-- Static tie table ---------------------------------------------------------------------------------------------------
-- OH_in_OD_isContained table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OH_in_OD_isContained (
    OH_ID_in integer not null, 
    OD_ID_isContained integer not null, 
    Metadata_OH_in_OD_isContained integer not null,
    constraint OH_in_OD_isContained_fkOH_in foreign key (
        OH_ID_in
    ) references public.OH_Orders(OH_ID), 
    constraint OH_in_OD_isContained_fkOD_isContained foreign key (
        OD_ID_isContained
    ) references public.OD_OrderDetails(OD_ID), 
    constraint pkOH_in_OD_isContained primary key (
        OD_ID_isContained 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- OH_isPlaced_CU_by table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OH_isPlaced_CU_by (
    OH_ID_isPlaced integer not null, 
    CU_ID_by integer not null, 
    Metadata_OH_isPlaced_CU_by integer not null,
    constraint OH_isPlaced_CU_by_fkOH_isPlaced foreign key (
        OH_ID_isPlaced
    ) references public.OH_Orders(OH_ID), 
    constraint OH_isPlaced_CU_by_fkCU_by foreign key (
        CU_ID_by
    ) references public.CU_Customers(CU_ID), 
    constraint pkOH_isPlaced_CU_by primary key (
        OH_ID_isPlaced 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- OH_isHandled_EM_by table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OH_isHandled_EM_by (
    OH_ID_isHandled integer not null, 
    EM_ID_by integer not null, 
    Metadata_OH_isHandled_EM_by integer not null,
    constraint OH_isHandled_EM_by_fkOH_isHandled foreign key (
        OH_ID_isHandled
    ) references public.OH_Orders(OH_ID), 
    constraint OH_isHandled_EM_by_fkEM_by foreign key (
        EM_ID_by
    ) references public.EM_Employees(EM_ID), 
    constraint pkOH_isHandled_EM_by primary key (
        OH_ID_isHandled 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- OH_isShipped_SH_via table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OH_isShipped_SH_via (
    OH_ID_isShipped integer not null, 
    SH_ID_via integer not null, 
    Metadata_OH_isShipped_SH_via integer not null,
    constraint OH_isShipped_SH_via_fkOH_isShipped foreign key (
        OH_ID_isShipped
    ) references public.OH_Orders(OH_ID), 
    constraint OH_isShipped_SH_via_fkSH_via foreign key (
        SH_ID_via
    ) references public.SH_Shippers(SH_ID), 
    constraint pkOH_isShipped_SH_via primary key (
        OH_ID_isShipped 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- OD_refers_PR_to table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.OD_refers_PR_to (
    OD_ID_refers integer not null, 
    PR_ID_to integer not null, 
    Metadata_OD_refers_PR_to integer not null,
    constraint OD_refers_PR_to_fkOD_refers foreign key (
        OD_ID_refers
    ) references public.OD_OrderDetails(OD_ID), 
    constraint OD_refers_PR_to_fkPR_to foreign key (
        PR_ID_to
    ) references public.PR_Products(PR_ID), 
    constraint pkOD_refers_PR_to primary key (
        OD_ID_refers 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- PR_isSupplied_SU_by table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.PR_isSupplied_SU_by (
    PR_ID_isSupplied integer not null, 
    SU_ID_by integer not null, 
    Metadata_PR_isSupplied_SU_by integer not null,
    constraint PR_isSupplied_SU_by_fkPR_isSupplied foreign key (
        PR_ID_isSupplied
    ) references public.PR_Products(PR_ID), 
    constraint PR_isSupplied_SU_by_fkSU_by foreign key (
        SU_ID_by
    ) references public.SU_Suppliers(SU_ID), 
    constraint pkPR_isSupplied_SU_by primary key (
        PR_ID_isSupplied 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- PR_isCategorized_CA_as table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.PR_isCategorized_CA_as (
    PR_ID_isCategorized integer not null, 
    CA_ID_as integer not null, 
    Metadata_PR_isCategorized_CA_as integer not null,
    constraint PR_isCategorized_CA_as_fkPR_isCategorized foreign key (
        PR_ID_isCategorized
    ) references public.PR_Products(PR_ID), 
    constraint PR_isCategorized_CA_as_fkCA_as foreign key (
        CA_ID_as
    ) references public.CA_Categories(CA_ID), 
    constraint pkPR_isCategorized_CA_as primary key (
        PR_ID_isCategorized 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- EM_to_EM_reports table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.EM_to_EM_reports (
    EM_ID_to integer not null, 
    EM_ID_reports integer not null, 
    Metadata_EM_to_EM_reports integer not null,
    constraint EM_to_EM_reports_fkEM_to foreign key (
        EM_ID_to
    ) references public.EM_Employees(EM_ID), 
    constraint EM_to_EM_reports_fkEM_reports foreign key (
        EM_ID_reports
    ) references public.EM_Employees(EM_ID), 
    constraint pkEM_to_EM_reports primary key (
        EM_ID_reports 
    )
);
-- KNOT EQUIVALENCE VIEWS ---------------------------------------------------------------------------------------------
--
-- Equivalence views combine the identity and equivalent parts of a knot into a single view, making
-- it look and behave like a regular knot. They also make it possible to retrieve data for only the
-- given equivalent.
--
-- @equivalent the equivalent that you want to retrieve data for
--
-- ATTRIBUTE EQUIVALENCE VIEWS ----------------------------------------------------------------------------------------
--
-- Equivalence views of attributes make it possible to retrieve data for only the given equivalent.
--
-- @equivalent the equivalent that you want to retrieve data for
--
-- KEY GENERATORS -----------------------------------------------------------------------------------------------------
--
-- These stored procedures can be used to generate identities of entities.
-- Corresponding anchors must have an incrementing identity column.
--
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kOH_Orders identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kOH_Orders(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.OH_Orders (
                Metadata_OH
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kOD_OrderDetails identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kOD_OrderDetails(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.OD_OrderDetails (
                Metadata_OD
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kCU_Customers identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kCU_Customers(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.CU_Customers (
                Metadata_CU
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kEM_Employees identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kEM_Employees(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.EM_Employees (
                Metadata_EM
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kSH_Shippers identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kSH_Shippers(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.SH_Shippers (
                Metadata_SH
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kPR_Products identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kPR_Products(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.PR_Products (
                Metadata_PR
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kSU_Suppliers identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kSU_Suppliers(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.SU_Suppliers (
                Metadata_SU
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kCA_Categories identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.kCA_Categories(
    requestedNumberOfIdentities bigint,
    metadata integer
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO public.CA_Categories (
                Metadata_CA
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- ATTRIBUTE TEMPORAL PERSPECTIVES ---------------------------------------------------------------------------------------
--
-- These table valued functions simplify temporal querying by providing a temporal
-- perspective of each attribute. There are three types of perspectives: latest,
-- point-in-time and now. 
--
-- The latest perspective shows the latest available information for each attribute.
-- The now perspective shows the information as it is right now.
-- The point-in-time perspective lets you travel through the information to the given timepoint.
--
-- @changingTimepoint the point in changing time to travel to
--
-- Under equivalence all these views default to equivalent = 0, however, corresponding
-- prepended-e perspectives are provided in order to select a specific equivalent.
--
-- @equivalent the equivalent for which to retrieve data
--
-- ANCHOR TEMPORAL PERSPECTIVES ---------------------------------------------------------------------------------------
--
-- These table valued functions simplify temporal querying by providing a temporal
-- perspective of each anchor. There are four types of perspectives: latest,
-- point-in-time, difference, and now. They also denormalize the anchor, its attributes,
-- and referenced knots from sixth to third normal form.
--
-- The latest perspective shows the latest available information for each anchor.
-- The now perspective shows the information as it is right now.
-- The point-in-time perspective lets you travel through the information to the given timepoint.
--
-- @changingTimepoint the point in changing time to travel to
--
-- The difference perspective shows changes between the two given timepoints, and for
-- changes in all or a selection of attributes.
--
-- @intervalStart the start of the interval for finding changes
-- @intervalEnd the end of the interval for finding changes
-- @selection a list of mnemonics for tracked attributes, ie 'MNE MON ICS', or null for all
--
-- Under equivalence all these views default to equivalent = 0, however, corresponding
-- prepended-e perspectives are provided in order to select a specific equivalent.
--
-- @equivalent the equivalent for which to retrieve data
--
-- SCHEMA EVOLUTION ---------------------------------------------------------------------------------------------------
--
-- The following tables, views, and functions are used to track schema changes
-- over time, as well as providing every XML that has been 'executed' against
-- the database.
--
-- Schema table -------------------------------------------------------------------------------------------------------
-- The schema table holds every xml that has been executed against the database
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public._Schema 
     ( version int generated by default as identity primary key
     , activation timestamp not null
     , schema jsonb not null
     )
;
-- Insert the JSON schema (as of now)
INSERT INTO public._Schema 
     ( activation
     , schema
     )
SELECT current_timestamp
     , '{
   "schema": {
      "format": "0.99.16",
      "date": "2026-01-22",
      "time": "02:05:09",
      "metadata": {
         "changingRange": "timestamp",
         "encapsulation": "public",
         "identity": "integer",
         "metadataPrefix": "Metadata",
         "metadataType": "integer",
         "metadataUsage": "true",
         "changingSuffix": "ChangedAt",
         "identitySuffix": "ID",
         "positIdentity": "integer",
         "positGenerator": "true",
         "positingRange": "timestamp",
         "positingSuffix": "PositedAt",
         "positorRange": "smallint",
         "positorSuffix": "Positor",
         "reliabilityRange": "decimal(5,2)",
         "reliabilitySuffix": "Reliability",
         "defaultReliability": "1",
         "deleteReliability": "0",
         "assertionSuffix": "Assertion",
         "partitioning": "true",
         "entityIntegrity": "true",
         "restatability": "true",
         "idempotency": "false",
         "assertiveness": "true",
         "naming": "improved",
         "positSuffix": "Posit",
         "annexSuffix": "Annex",
         "chronon": "timestamp",
         "now": "current_timestamp",
         "dummySuffix": "Dummy",
         "versionSuffix": "Version",
         "statementTypeSuffix": "StatementType",
         "checksumSuffix": "Checksum",
         "businessViews": "true",
         "decisiveness": "true",
         "equivalence": "true",
         "equivalentSuffix": "EQ",
         "equivalentRange": "smallint",
         "databaseTarget": "PostgreSQL",
         "temporalization": "uni",
         "deletability": "false",
         "deletablePrefix": "Deletable",
         "deletionSuffix": "Deleted",
         "privacy": "Ignore",
         "checksum": "false",
         "triggers": "true",
         "knotAliases": "true"
      },
      "anchor": {
         "OH": {
            "id": "OH",
            "mnemonic": "OH",
            "descriptor": "Orders",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "686.33",
               "y": "415.21",
               "fixed": "false"
            }
         },
         "OD": {
            "id": "OD",
            "mnemonic": "OD",
            "descriptor": "OrderDetails",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "576.89",
               "y": "224.09",
               "fixed": "false"
            }
         },
         "CU": {
            "id": "CU",
            "mnemonic": "CU",
            "descriptor": "Customers",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "618.07",
               "y": "544.43",
               "fixed": "false"
            }
         },
         "EM": {
            "id": "EM",
            "mnemonic": "EM",
            "descriptor": "Employees",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "923.01",
               "y": "461.11",
               "fixed": "false"
            }
         },
         "SH": {
            "id": "SH",
            "mnemonic": "SH",
            "descriptor": "Shippers",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "495.36",
               "y": "435.73",
               "fixed": "false"
            }
         },
         "PR": {
            "id": "PR",
            "mnemonic": "PR",
            "descriptor": "Products",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "432.99",
               "y": "145.57",
               "fixed": "false"
            }
         },
         "SU": {
            "id": "SU",
            "mnemonic": "SU",
            "descriptor": "Suppliers",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "433.61",
               "y": "-1.01",
               "fixed": "false"
            }
         },
         "CA": {
            "id": "CA",
            "mnemonic": "CA",
            "descriptor": "Categories",
            "identity": "integer",
            "metadata": {
               "capsule": "public",
               "generator": "true"
            },
            "layout": {
               "x": "257.37",
               "y": "135.85",
               "fixed": "false"
            }
         }
      },
      "anchors": [
         "OH",
         "OD",
         "CU",
         "EM",
         "SH",
         "PR",
         "SU",
         "CA"
      ],
      "tie": {
         "OH_in_OD_isContained": {
            "id": "OH_in_OD_isContained",
            "anchorRole": {
               "OH_in": {
                  "id": "OH_in",
                  "role": "in",
                  "type": "OH",
                  "identifier": "false"
               },
               "OD_isContained": {
                  "id": "OD_isContained",
                  "role": "isContained",
                  "type": "OD",
                  "identifier": "true"
               }
            },
            "roles": [
               "OH_in",
               "OD_isContained"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "626.91",
               "y": "301.96",
               "fixed": "false"
            }
         },
         "OH_isPlaced_CU_by": {
            "id": "OH_isPlaced_CU_by",
            "anchorRole": {
               "OH_isPlaced": {
                  "id": "OH_isPlaced",
                  "role": "isPlaced",
                  "type": "OH",
                  "identifier": "true"
               },
               "CU_by": {
                  "id": "CU_by",
                  "role": "by",
                  "type": "CU",
                  "identifier": "false"
               }
            },
            "roles": [
               "OH_isPlaced",
               "CU_by"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "655.64",
               "y": "495.41",
               "fixed": "false"
            }
         },
         "OH_isHandled_EM_by": {
            "id": "OH_isHandled_EM_by",
            "anchorRole": {
               "OH_isHandled": {
                  "id": "OH_isHandled",
                  "role": "isHandled",
                  "type": "OH",
                  "identifier": "true"
               },
               "EM_by": {
                  "id": "EM_by",
                  "role": "by",
                  "type": "EM",
                  "identifier": "false"
               }
            },
            "roles": [
               "OH_isHandled",
               "EM_by"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "795.41",
               "y": "455.37",
               "fixed": "false"
            }
         },
         "OH_isShipped_SH_via": {
            "id": "OH_isShipped_SH_via",
            "anchorRole": {
               "OH_isShipped": {
                  "id": "OH_isShipped",
                  "role": "isShipped",
                  "type": "OH",
                  "identifier": "true"
               },
               "SH_via": {
                  "id": "SH_via",
                  "role": "via",
                  "type": "SH",
                  "identifier": "false"
               }
            },
            "roles": [
               "OH_isShipped",
               "SH_via"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "573.36",
               "y": "422.59",
               "fixed": "false"
            }
         },
         "OD_refers_PR_to": {
            "id": "OD_refers_PR_to",
            "anchorRole": {
               "OD_refers": {
                  "id": "OD_refers",
                  "role": "refers",
                  "type": "OD",
                  "identifier": "true"
               },
               "PR_to": {
                  "id": "PR_to",
                  "role": "to",
                  "type": "PR",
                  "identifier": "false"
               }
            },
            "roles": [
               "OD_refers",
               "PR_to"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "489.08",
               "y": "200.86",
               "fixed": "false"
            }
         },
         "PR_isSupplied_SU_by": {
            "id": "PR_isSupplied_SU_by",
            "anchorRole": {
               "PR_isSupplied": {
                  "id": "PR_isSupplied",
                  "role": "isSupplied",
                  "type": "PR",
                  "identifier": "true"
               },
               "SU_by": {
                  "id": "SU_by",
                  "role": "by",
                  "type": "SU",
                  "identifier": "false"
               }
            },
            "roles": [
               "PR_isSupplied",
               "SU_by"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "430.11",
               "y": "41.32",
               "fixed": "false"
            }
         },
         "PR_isCategorized_CA_as": {
            "id": "PR_isCategorized_CA_as",
            "anchorRole": {
               "PR_isCategorized": {
                  "id": "PR_isCategorized",
                  "role": "isCategorized",
                  "type": "PR",
                  "identifier": "true"
               },
               "CA_as": {
                  "id": "CA_as",
                  "role": "as",
                  "type": "CA",
                  "identifier": "false"
               }
            },
            "roles": [
               "PR_isCategorized",
               "CA_as"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "334.38",
               "y": "140.68",
               "fixed": "false"
            }
         },
         "EM_to_EM_reports": {
            "id": "EM_to_EM_reports",
            "anchorRole": {
               "EM_to": {
                  "id": "EM_to",
                  "role": "to",
                  "type": "EM",
                  "identifier": "false"
               },
               "EM_reports": {
                  "id": "EM_reports",
                  "role": "reports",
                  "type": "EM",
                  "identifier": "true"
               }
            },
            "roles": [
               "EM_to",
               "EM_reports"
            ],
            "metadata": {
               "capsule": "public",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "1021.00",
               "y": "453.00",
               "fixed": "true"
            }
         }
      },
      "ties": [
         "OH_in_OD_isContained",
         "OH_isPlaced_CU_by",
         "OH_isHandled_EM_by",
         "OH_isShipped_SH_via",
         "OD_refers_PR_to",
         "PR_isSupplied_SU_by",
         "PR_isCategorized_CA_as",
         "EM_to_EM_reports"
      ]
   }
}'
;
-- Schema expanded view -----------------------------------------------------------------------------------------------
-- A view of the schema table that expands the XML attributes into columns
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Schema_Expanded 
AS
SELECT version
     , activation
     , (schema -> 'schema' ->> 'format') as format
     , (schema -> 'schema' ->> 'date')::date as date
     , (schema -> 'schema' ->> 'time')::time as time
     , (schema -> 'schema' -> 'metadata' ->> 'temporalization') as temporalization
     , (schema -> 'schema' -> 'metadata' ->> 'databaseTarget') as databaseTarget	
     , (schema -> 'schema' -> 'metadata' ->> 'changingRange') as changingRange
     , (schema -> 'schema' -> 'metadata' ->> 'encapsulation') as encapsulation
     , (schema -> 'schema' -> 'metadata' ->> 'identity') as identity
     , (schema -> 'schema' -> 'metadata' ->> 'metadataPrefix') as metadataPrefix
     , (schema -> 'schema' -> 'metadata' ->> 'metadataType') as metadataType
     , (schema -> 'schema' -> 'metadata' ->> 'metadataUsage') as metadataUsage	
     , (schema -> 'schema' -> 'metadata' ->> 'changingSuffix') as changingSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'identitySuffix') as identitySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'positIdentity') as positIdentity
     , (schema -> 'schema' -> 'metadata' ->> 'positGenerator') as positGenerator	
     , (schema -> 'schema' -> 'metadata' ->> 'positingRange') as positingRange
     , (schema -> 'schema' -> 'metadata' ->> 'positingSuffix') as positingSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'positorRange') as positorRange
     , (schema -> 'schema' -> 'metadata' ->> 'positorSuffix') as positorSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'reliabilityRange') as reliabilityRange
     , (schema -> 'schema' -> 'metadata' ->> 'reliabilitySuffix') as reliabilitySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'reliableCutoff') as reliableCutoff
     , (schema -> 'schema' -> 'metadata' ->> 'deleteReliability') as deleteReliability	
     , (schema -> 'schema' -> 'metadata' ->> 'reliableSuffix') as reliableSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'partitioning') as partitioning
     , (schema -> 'schema' -> 'metadata' ->> 'entityIntegrity') as entityIntegrity
     , (schema -> 'schema' -> 'metadata' ->> 'restatability') as restatability
     , (schema -> 'schema' -> 'metadata' ->> 'idempotency') as idempotency
     , (schema -> 'schema' -> 'metadata' ->> 'assertiveness') as assertiveness	
     , (schema -> 'schema' -> 'metadata' ->> 'naming') as naming
     , (schema -> 'schema' -> 'metadata' ->> 'positSuffix') as positSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'annexSuffix') as annexSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'chronon') as chronon
     , (schema -> 'schema' -> 'metadata' ->> 'now') as now
     , (schema -> 'schema' -> 'metadata' ->> 'dummySuffix') as dummySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'statementTypeSuffix') as statementTypeSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'checksumSuffix') as checksumSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'businessViews') as businessViews
     , (schema -> 'schema' -> 'metadata' ->> 'equivalence') as equivalence
     , (schema -> 'schema' -> 'metadata' ->> 'equivalentSuffix') as equivalentSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'equivalentRange') as equivalentRange	
  FROM public._Schema
;
-- Anchor view --------------------------------------------------------------------------------------------------------
-- The anchor view shows information about all the anchors in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Anchor
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , a.key || '_' || v.descriptor as name
     , v.descriptor	
     , a.key as mnemonic	
     , v.metadata ->> 'capsule' as capsule
     , v.identity
     , v.metadata ->> 'generator' as generator
     , coalesce(cardinality(v.attributes),0) as numberOfAttributes
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'anchor') as a
     , jsonb_to_record(a.value) as v(descriptor text, identity text, "dataRange" text, metadata jsonb, attributes text[])
;	
-- Knot view ----------------------------------------------------------------------------------------------------------
-- The knot view shows information about all the knots in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Knot
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , k.key || '_' || v.descriptor as name	
     , v.descriptor
     , k.key as mnemonic	
     , v.metadata ->> 'capsule' as capsule
     , v."dataRange" as datarange	
     , v.identity
     , v.metadata ->> 'generator' as generator
     , coalesce(v.metadata ->> 'checksum','false') as checksum
     , v.description	
     , coalesce(v.metadata ->> 'equivalent','false') as equivalent
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'knot') as k
     , jsonb_to_record(k.value) as v(descriptor text, identity text, "dataRange" text, description text, metadata jsonb)
;
-- Attribute view -----------------------------------------------------------------------------------------------------
-- The attribute view shows information about all the attributes in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Attribute
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , a.key || '_' || t.key || '_' || (a.value ->> 'descriptor') || '_' || v.descriptor as name
     , v.descriptor 
     , t.key as mnemonic 
     , v.metadata ->> 'capsule' as capsule
     , v."dataRange" as dataRange
     , case when v."knotRange" is null then false else true end as knotted
     , v."knotRange" as knotRange
     , case when v."timeRange" is null then false else true end as historized 
     , v."timeRange" as timeRange 
     , v.metadata ->> 'generator' as generator 
     , v.metadata ->> 'assertive' as assertive 
     , v.metadata ->> 'privacy' as privacy
     , coalesce(v.metadata ->> 'checksum','false') as checksum 
     , coalesce(v.metadata ->> 'equivalent','false') as equivalent
     , v.metadata ->> 'restatable' as restatable 
     , v.metadata ->> 'idempotent' as idempotent 
     , a.key as anchorMnemonic
     , (a.value ->> 'descriptor') as anchorDescriptor
     , (a.value ->> 'identity') as anchorIdentity
     , v.metadata ->> 'deletable' as deletable
     , v.metadata ->> 'encryptionGroup' as encryptionGroup
     , v.description
     , coalesce(cardinality(v.keys),0) as numberKeyOfStops
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'anchor') as a
     , jsonb_each(a.value -> 'attribute') as t
     , jsonb_to_record(t.value) as v(descriptor text, identity text, "dataRange" text, "knotRange" text, "timeRange" text, description text, metadata jsonb, keys text[]) 
;
-- Tie view -----------------------------------------------------------------------------------------------------------
-- The tie view shows information about all the ties in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW public._Tie
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , t.key as name
     , v.metadata ->> 'capsule' as capsule	
     , case when v."timeRange" is null then false else true end as historized 
     , v."timeRange" as timeRange
     , cardinality(roles) as numberOfRoles
     , array(select value ->> 'role' from jsonb_each(v."anchorRole")) || array(select value ->> 'role' from jsonb_each(v."knotRole")) as roles
     , cardinality(array(select jsonb_object_keys(v."anchorRole"))) as numberOfAnchors
     , array(select split_part(jsonb_object_keys(v."anchorRole"),'_',1)) as anchors
     , coalesce(cardinality(array(select jsonb_object_keys(v."knotRole")))) as numberOfKnots
     , array(select split_part(jsonb_object_keys(v."knotRole"),'_',1)) as knots	
     --, v."anchorRole"
     , cardinality(array(select value ->> 'identifier' from jsonb_each(v."anchorRole") where value ->> 'identifier' = 'true') || array(select value ->> 'identifier' from jsonb_each(v."knotRole") where value ->> 'identifier' = 'true')) as identifiers
     , v.metadata ->> 'generator' as generator 
     , v.metadata ->> 'assertive' as assertive 
     , v.metadata ->> 'restatable' as restatable 
     , v.metadata ->> 'idempotent' as idempotent 
  FROM public._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'tie') as t
     , jsonb_to_record(t.value) as v("timeRange" text, roles text[], metadata jsonb, "anchorRole" jsonb, "knotRole" jsonb)
;